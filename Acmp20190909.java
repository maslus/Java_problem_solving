//Золотой песок
//        (Время: 1 сек. Память: 16 Мб Сложность: 10%)
//        Сотрудники завода по производству золотого песка из воздуха решили поправить свое финансовое положение. Они пробрались на склад завода, где хранился золотой песок трех видов. Один килограмм золотого песка первого вида они смогли бы продать за A1 рублей, второго вида – за A2 рублей, а третьего вида – за A3 рублей. Так получилось, что у сотрудников оказалось с собой только три емкости: первая была рассчитана на B1 килограмм груза, вторая на B2 килограмм, а третья на B3 килограмм. Им надо было заполнить полностью все емкости таким образом, чтобы получить как можно больше денег за весь песок. При заполнении емкостей нельзя смешивать песок разных видов, то есть, в одну емкость помещать более одного вида песка, и заполнять емкости песком так, чтобы один вид песка находился более чем в одной емкости.
//
//        Требуется написать программу, которая определяет, за какую сумму предприимчивые сотрудники смогут продать весь песок в случае наилучшего для себя заполнения емкостей песком.
//
//        Входные данные
//        В единственной строке входного файла INPUT.TXT записано 6 натуральных чисел A1, A2, A3, B1, B2, B3, записанных в одной строке через пробел. Все числа не превосходят 100.
//
//        Выходные данные
//        В единственную строку выходного файла OUTPUT.TXT нужно вывести единственное целое число – сумму в рублях, которую смогут сотрудники заработать в случае наилучшего для себя заполнения емкостей песком.

import java.io.*;
import java.util.*;

public class Acmp20190909 {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        PrintWriter out = new PrintWriter(System.out);

        int a1 = in.nextInt();
        int a2 = in.nextInt();
        int a3 = in.nextInt();
        int b1 = in.nextInt();
        int b2 = in.nextInt();
        int b3 = in.nextInt();

        int summA = a1 + a2 + a3;
        int summB = b1 + b2 + b3;

        out.println(Math.max(Math.max(a1, a2), a3) * Math.max(Math.max(b1, b2), b3) +
                Math.min(Math.min(a1, a2), a3) * Math.min(Math.min(b1, b2), b3) +
                (summA - Math.max(Math.max(a1, a2), a3) - Math.min(Math.min(a1, a2), a3)) *
                        (summB - Math.max(Math.max(b1, b2), b3) - Math.min(Math.min(b1, b2), b3)));

        out.flush();
    }
}

//Время года
//        (Время: 1 сек. Память: 16 Мб Сложность: 10%)
//        По заданному номеру месяца в году требуется определить время года.
//
//        Входные данные
//        Входной файл INPUT.TXT содержит натуральное число N (N≤100) – номер месяца.
//
//        Выходные данные
//        В выходной файл OUTPUT.TXT выведите для летних месяцев значение «Summer», для зимних – «Winter», для весенних – «Spring», для осенних – «Autumn». Если число не соответствует возможному значению месяца, то в этом случае следует вывести «Error».


//import java.io.*;
//import java.util.*;
//
//public class Acmp20190909 {
//    public static void main(String[] args) {
//        Scanner in = new Scanner(System.in);
//        PrintWriter out = new PrintWriter(System.out);
//
//        int a = in.nextInt();
//
//        if (a == 1 || a == 2 || a == 12)
//            out.println("Winter");
//        else if (a == 3 || a == 4 || a == 5)
//            out.println("Spring");
//        else if (a == 6 || a == 7 || a == 8)
//            out.println("Summer");
//        else if (a == 9 || a == 10 || a == 11)
//            out.println("Autumn");
//        else out.println("Error");
//
//        out.flush();
//    }
//}

//Внеземные гости
//        (Время: 1 сек. Память: 16 Мб Сложность: 10%)
//        Недавно на поле фермера Джона были обнаружены следы приземления летающих тарелок. Об этом даже писала газета Mew Yorc Courier.
//
//        Поле фермера Джона имеет форму круга радиусом r1. По сообщениям журналистов были обнаружены два следа от летающих тарелок, имевшие форму кругов. Один из них имел радиус r2, второй - радиус r3. Также сообщается, что они находились внутри поля фермера Джона и не пересекались, ни один из них не лежал внутри другого. При этом, они, возможно, касались друг друга и/или границы поля.
//
//        Поскольку журналисты часто склонны преувеличивать масштабы событий, необходимо написать программу, которая будет проверять, могли ли иметь место события, описанные в газете.
//
//        Входные данные
//        Входной файл INPUT.TXT содержит три целых положительных числа - r1, r2, r3 (1 ≤ r1, r2, r3 ≤ 109).
//
//        Выходные данные
//        В выходной файл OUTPUT.TXT выведите слово YES, если информация, опубликованная в газете, может соответствовать правде, и слово NO - иначе.

//import java.io.*;
//import java.util.*;
//
//public class Acmp20190909{
//    public static void main(String[] args){
//        Scanner in = new Scanner(System.in);
//        PrintWriter out = new PrintWriter(System.out);
//
//        int r1 = in.nextInt();
//        int r2 = in.nextInt();
//        int r3 = in.nextInt();
//        if (r1>=r2+r3)out.println("YES");
//        else out.println("NO");
//
//        out.flush();
//    }
//}

//Разворот
//        (Время: 1 сек. Память: 16 Мб Сложность: 9%)
//        Дано натуральное число N и последовательность из N элементов. Требуется вывести эту последовательность в обратном порядке.
//
//        Входные данные
//        В первой строке входного файла INPUT.TXT записано натуральное число N (N ≤ 103). Во второй строке через пробел идут N целых чисел, по модулю не превосходящих 103 - элементы последовательности.
//
//        Выходные данные
//        В выходной файл OUTPUT.TXT выведите заданную последовательность в обратном порядке.

//import java.io.*;
//import java.util.*;
//
//public class Acmp20190909{
//    public static void main(String[] args){
//        Scanner in = new Scanner(System.in);
//        PrintWriter out = new PrintWriter(System.out);
//
//        int n = in.nextInt();
//        int[] arr = new int[n];
//
//        for (int i = 0; i < n; i++) {
//            arr[i] = in.nextInt();
//        }
//
//        for (int i = n-1; i >=0 ; i--) {
//            out.print(arr[i]+" ");
//        }
//
//
//        out.flush();
//    }
//}

//От перестановки что-то меняется ...
//        (Время: 1 сек. Память: 16 Мб Сложность: 9%)
//        Всем известно, что «от перестановки слагаемых сумма не изменяется». Однако, случается и так, что перестановка двух чисел приводит к более интересным последствиям.
//
//        Пусть, например, заданы три числа: a1, a2, a3. Рассмотрим равенство a1+ a2= a3. Оно может быть неверным (например, если a1= 1, a2= 4, a3= 3), однако может стать верным, если поменять некоторые числа местами (например, если поменять местами a2 и a3, оно обратится в равенство 1 + 3 = 4).
//
//        Ваша задача – по заданным трем числам определить: можно ли их переставить так, чтобы сумма первых двух равнялась третьему.
//
//        Входные данные
//        Входной файл INPUT.TXT содержит три целых числа: a1, a2, a3 (−108 ≤ a1, a2, a3 ≤ 108).
//
//        Выходные данные
//        В выходной файл OUTPUT.TXT выведите слово «YES», если заданные числа можно переставить так, чтобы сумма первых двух равнялась третьему. В противном случае выведите в выходной файл слово «NO».

//import java.io.*;
//import java.util.*;
//
//public class Acmp20190909{
//    public static void main(String[] args){
//        Scanner in = new Scanner(System.in);
//        PrintWriter out = new PrintWriter(System.out);
//
//        int a = in.nextInt();
//        int b = in.nextInt();
//        int c = in.nextInt();
//
//        if (a==b+c||b==a+c||c==a+b){
//            out.println("YES");
//        } else {
//            out.println("NO");
//        }
//
//        out.flush();
//    }
//}

//Мышка
//        (Время: 1 сек. Память: 16 Мб Сложность: 9%)
//        Однажды компьютерная мышка подумала, что стоит взять про запас еще один коврик. Чтобы никто не заметил запасного коврика, мышка решила его спрятать под свой прямоугольный коврик. Пробравшись ночью на склад, мышка обнаружила там только круглые коврики. Удастся ли мышке спрятать круглый коврик под прямоугольным ковриком?
//
//        Входные данные
//        Входной файл INPUT.TXT содержит три натуральных числа: W, H и R, где W и H - ширина и высота прямоугольного коврика, а R – радиус запасного коврика. Все числа не превосходят значения 109.
//
//        Выходные данные
//        В выходной файл OUTPUT.TXT выведите «YES», если новый коврик можно спрятать под старым, и слово «NO», если этого сделать нельзя.

//import java.io.*;
//import java.util.*;
//
//public class Acmp20190909{
//    public static void main(String[] args){
//        Scanner in = new Scanner(System.in);
//        PrintWriter out = new PrintWriter(System.out);
//
//        int w = in.nextInt();
//        int h = in.nextInt();
//        int r = in.nextInt();
//
//        if (w>=r*2&&h>=r*2){
//            out.println("YES");
//        } else {
//            out.println("NO");
//        }
//
//        out.flush();
//    }
//}

//Пятью пять - двадцать пять!
//        (Время: 1 сек. Память: 16 Мб Сложность: 8%)
//        Вася и Петя учатся в школе в одном классе. Недавно Петя поведал Васе о хитром способе возведения в квадрат натуральных чисел, оканчивающихся на цифру 5. Теперь Вася может с легкостью возводить в квадрат двузначные (и даже некоторые трехзначные) числа, оканчивающиеся на 5. Способ заключается в следующем: для возведения в квадрат числа, оканчивающегося на 5 достаточно умножить число, полученное из исходного вычеркиванием последней пятерки на следующее по порядку число, затем остается лишь приписать «25» к получившемуся результату справа. Например, для того, чтобы возвести число 125 в квадрат достаточно 12 умножить на 13 и приписать 25, т.е. приписывая к числу 12*13=156 число 25, получаем результат 15625, т.е. 1252=15625. Напишите программу, возводящую число, оканчивающееся на 5, в квадрат для того, чтобы Вася смог проверить свои навыки.
//
//        Входные данные
//        В единственной строке входного файла INPUT.TXT записано одно натуральное число А, оканчивающееся на цифру 5, не превышающее 4*105.
//
//        Выходные данные
//        В выходной файл OUTPUT.TXT выведите одно натуральное число - A2 без лидирующих нулей.

//import java.io.*;
//import java.util.*;
//
//public class Acmp20190909{
//    public static void main(String[] args){
//        Scanner in = new Scanner(System.in);
//        PrintWriter out = new PrintWriter(System.out);
//
//        long a = in.nextLong();
//        long b=(a-5)/10;
//        long c = b*(b+1);
//        long a2= c*100+25;
//
//        out.println(a2);
//
//        out.flush();
//    }
//}

//Монетки
//        (Время: 1 сек. Память: 16 Мб Сложность: 8%)
//        На столе лежат n монеток. Некоторые из них лежат вверх решкой, а некоторые – гербом. Определите минимальное число монеток, которые нужно перевернуть, чтобы все монетки были повернуты вверх одной и той же стороной.
//
//        Монетки
//        Входные данные
//        В первой строке входного файла INPUT.TXT записано натуральное число N (1 ≤ N ≤ 100) – число монеток. В каждой из последующих N строк содержится одно целое число – 1 если монетка лежит решкой вверх и 0 если вверх гербом.
//
//        Выходные данные
//        В выходной файл OUTPUT.TXT выведите минимальное количество монет, которые нужно перевернуть.


//import java.io.*;
//import java.util.*;
//
//public class Acmp20190909 {
//    public static void main(String[] args) {
//        Scanner in = new Scanner(System.in);
//        PrintWriter out = new PrintWriter(System.out);
//
//        int n = in.nextInt();
//        int[] arr = new int[n];
//        int count = 0;
//
//        for (int i = 0; i < n; i++) {
//            arr[i] = in.nextInt();
//            count += arr[i];
//        }
//
//        if (count>n/2){
//            out.println(n-count);
//        } else {
//            out.println(count);
//        }
//
//        out.flush();
//    }
//}